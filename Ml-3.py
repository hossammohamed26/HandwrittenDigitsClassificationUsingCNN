# -*- coding: utf-8 -*-
"""Ml-3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-jKMI-sXEdDW0LarCWM5XCTmnM3Xg0xu
"""

from tensorflow.keras.layers import Flatten
from tensorflow.keras.layers import Dense
from tensorflow.keras.layers import MaxPooling2D
from tensorflow.keras.layers import Conv2D
from tensorflow.keras.models import Sequential
import pandas as pd
import tensorflow.keras.models as km
import tensorflow.keras.layers as kl
import tensorflow as tf
import numpy as np
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split

def load_dataset():
    mnist = tf.keras.datasets.mnist

    (x_train, y_train), (x_test, y_test) = mnist.load_data()
    x_train = np.array(x_train.reshape((x_train.shape[0], 28, 28, 1)))
    x_test = np.array(x_test.reshape((x_test.shape[0], 28, 28, 1)))
   
    return x_train, y_train, x_test, y_test

def normalize_data(x_train, x_test):
    x_train_normalized = x_train.astype('float32')
    x_test_normalized = x_test.astype('float32')
    x_train_normalized = x_train_normalized/255.0
    x_test_normalized = x_test_normalized/255.0
    return x_train_normalized, x_test_normalized

def cnn_model_1():
    model = Sequential()
    # kernel_initializer='he_uniform' :Draws samples from a uniform distribution within [-limit, limit]
    #, where limit = sqrt(6 / fan_in)
    #(fan_in is the number of input units in the weight tensor).
    #FIRST CONV LAYER
    model.add(Conv2D(64, (3, 3), activation='relu',
              kernel_initializer='he_uniform', input_shape=(28, 28, 1))) #Initializers define the way to set the initial random weights of Keras layers.
    
    model.add(MaxPooling2D((2, 2))) #single maximum value of 2x2 will be taken
    #SECOND CONV LAYER 
    model.add(Conv2D(64, (3, 3), activation='relu',
              kernel_initializer='he_uniform', input_shape=(28, 28, 1)))
    
    model.add(MaxPooling2D((2, 2)))
    
    
    model.add(Flatten()) #from 2D to 1D
    #FIRST DENSE LAYER
    model.add(Dense(100, activation='relu', kernel_initializer='he_uniform')) #fully connected ANN
    #SECOND DENSE LAYER
    model.add(Dense(64,activation='relu'))
    #OUTPUT LAYER
    model.add(Dense(10, activation='softmax'))
    
    return model

def cnn_model_2():
    model = Sequential()
    
    #FIRST CONV LAYER
    model.add(Conv2D(64, (3, 3), activation='relu',
              kernel_initializer='he_uniform', input_shape=(28, 28, 1))) #Initializers define the way to set the initial random weights of Keras layers.
    
    model.add(MaxPooling2D((2, 2))) #single maximum value of 2x2 will be taken
    
    
    model.add(Flatten()) #from 2D to 1D
    #FIRST DENSE LAYER
    model.add(Dense(50, activation='relu', kernel_initializer='he_uniform')) #fully connected ANN
    #SECOND DENSE LAYER
    model.add(Dense(32,activation='relu'))
    #OUTPUT LAYER
    model.add(Dense(10, activation='softmax'))
    
    return model

def cnn_model_3():
    model = Sequential()
    
    #FIRST CONV LAYER
    model.add(Conv2D(64, (3, 3), activation='relu',
              kernel_initializer='he_uniform', input_shape=(28, 28, 1))) #Initializers define the way to set the initial random weights of Keras layers.
    
    model.add(MaxPooling2D((2, 2))) #single maximum value of 2x2 will be taken
    #SECOND CONV LAYER 
    model.add(Conv2D(64, (3, 3), activation='relu',
              kernel_initializer='he_uniform', input_shape=(28, 28, 1)))
    
    model.add(MaxPooling2D((2, 2)))
    #THIRD CONV LAYER 
    model.add(Conv2D(32, (3, 3), activation='relu',
              kernel_initializer='he_uniform', input_shape=(28, 28, 1)))
    
    model.add(MaxPooling2D((2, 2)))
    
    
    model.add(Flatten()) #from 2D to 1D
    #FIRST DENSE LAYER
    model.add(Dense(100, activation='relu', kernel_initializer='he_uniform')) #fully connected ANN
    #SECOND DENSE LAYER
    model.add(Dense(64,activation='relu'))
    #OUTPUT LAYER
    model.add(Dense(10, activation='softmax'))
    
    return model

def cnn_model_4():
    model = Sequential()
    
    #FIRST CONV LAYER
    model.add(Conv2D(128, (3, 3), activation='relu',
              kernel_initializer='he_uniform', input_shape=(28, 28, 1))) #Initializers define the way to set the initial random weights of Keras layers.
    
    model.add(MaxPooling2D((2, 2))) #single maximum value of 2x2 will be taken
    #SECOND CONV LAYER 
    model.add(Conv2D(16, (3, 3), activation='relu',
              kernel_initializer='he_uniform', input_shape=(28, 28, 1)))
    
    model.add(MaxPooling2D((2, 2)))
    
    
    model.add(Flatten()) #from 2D to 1D
    #FIRST DENSE LAYER
    model.add(Dense(64, activation='relu', kernel_initializer='he_uniform')) #fully connected ANN
    
    #OUTPUT LAYER
    model.add(Dense(10, activation='softmax'))
    
    return model

def kFold(model, mN, x_train, y_train, x_test, y_test):
    error=0
    acc=0
    nEpochs=2
    print("Model",mN)
    for i in range(5):
        #spliting data into train & val
        xTrain, vxTrain, yTrain, vyTrain = train_test_split(x_train, y_train, test_size=.2)

        print("Fold", i+1)
        model.compile(loss="sparse_categorical_crossentropy", optimizer="adam", metrics=['accuracy'])

        #training the model
        hist = model.fit(xTrain, yTrain, epochs = nEpochs, shuffle = True, validation_data=(vxTrain, vyTrain))
        error += sum(np.array(hist.history['val_loss'])) / nEpochs
        acc += sum(np.array(hist.history['val_accuracy'])) / nEpochs

    error/=5
    acc/=5

    #Avg error
    print("Avg error of the validation", error)
    print("Avg accuracy of the validation", acc)
    #Accuracy for test
    test_loss, test_acc = model.evaluate(x_test,y_test)
    print("Test loss", test_loss)
    print("Test accuracy", test_acc)
    print('-----------------------------------------------------------------------------------------------------------------------------')
    return error,acc, test_loss, test_acc

x_train, y_train, x_test, y_test = load_dataset()
x_train_normalized, x_test_normalized = normalize_data(x_train, x_test)

error1, vAcc1, test_loss1, test_acc1 = kFold(cnn_model_1(), 1, x_train_normalized, y_train, x_test_normalized, y_test)

error2, vAcc2, test_loss2, test_acc2 = kFold(cnn_model_2(), 2, x_train_normalized, y_train, x_test_normalized, y_test)

error3, vAcc3, test_loss3, test_acc3 = kFold(cnn_model_3(), 3, x_train_normalized, y_train, x_test_normalized, y_test)

error4, vAcc4, test_loss4, test_acc4 = kFold(cnn_model_4(), 4, x_train_normalized, y_train, x_test_normalized, y_test)

file = open("Output.txt", "w")
file.write("Model 1\n")
file.write("Avg error of the validation "+ str(error1)+ "\n")
file.write("Avg accuracy of the validation "+ str(vAcc1)+ "\n")
file.write("Test loss "+ str(test_loss1)+ "\n")
file.write("Test accuracy "+ str(test_acc1)+ "\n")
file.write("---------------------------------------\n")

file.write("Model 2\n")
file.write("Avg error of the validation "+ str(error2)+ "\n")
file.write("Avg accuracy of the validation "+ str(vAcc2)+ "\n")
file.write("Test loss "+ str(test_loss2)+ "\n")
file.write("Test accuracy "+ str(test_acc2)+ "\n")
file.write("---------------------------------------\n")

file.write("Model 3\n")
file.write("Avg error of the validation "+ str(error3)+ "\n")
file.write("Avg accuracy of the validation "+ str(vAcc3)+ "\n")
file.write("Test loss "+ str(test_loss3)+ "\n")
file.write("Test accuracy "+ str(test_acc3)+ "\n")
file.write("---------------------------------------\n")

file.write("Model 4\n")
file.write("Avg error of the validation "+ str(error4)+ "\n")
file.write("Avg accuracy of the validation "+ str(vAcc4)+ "\n")
file.write("Test loss "+ str(test_loss4)+ "\n")
file.write("Test accuracy "+ str(test_acc4)+ "\n")
file.write("---------------------------------------\n")
file.close()